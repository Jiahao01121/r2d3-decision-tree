import _ from 'lodash';
import { createSelector } from 'reselect';
import d3 from 'd3';

import { tree_data, tree_training_set, tree_stats, tree_test_set, test_stats } from './tree-training-set-98.js';


const initialState = {
	tree: {
		nodes: [
			{ id: 1 },
			{ id: 2 }
		]
	},
	samples: [],
	sample_sets: [],

	ui: {
		sample_hover_id: null,
		tree_node_hover_id: null,
		animation_extent: 0,
		canvas_size: { width: 600,
		               height: 900 },
		scales: { x: null,
		          y: null }
	}
};

let state = Object.assign({}, initialState);
let test_set = ComputeTestTree(tree_data, tree_test_set);
let tree_layout = d3.layout.tree()
		.separation(() => 1)
		.children((d) => _.map(d.children, (i) => state.tree.nodes[i]));

// memoized selectors
const treeNodesSelector => state.tree.nodes;
const samplesSelector => state.samples;
const sampleSetsSelector => state.samples_sets;


var ComputeTestTree = function(tree, test_set) {
  var test_tree = _.assignIn({}, tree);
  var test_stats = [];

  var partitionFork = function(tree, data, depth) {
    tree.samples = data.length;

    // Partition based on if data is Target
    var target = _.partition(data, function(d) {
      return d.target > 0.5;
    });

    // Partition based on if data is above or below split
    var split = _.partition(data, function(d) {
      return d[tree.key] > parseFloat(tree.value);
    });

    // Compute Gini for Given Node
    var isTargetLength = target[0].length/data.length;
    var isNotTargetLength = target[1].length/data.length;
    var gini = 1 - (isTargetLength*isTargetLength + isNotTargetLength*isNotTargetLength);

    tree.gini = gini;

    // Some additional Statistics about the data
    var hasChildren = (split[0].length > 0 && split[1].length >0);
    var max = _.max(data, function(d) {
      return d[tree.key];
    })[tree.key];
    var min = _.min(data, function(d) {
      return d[tree.key];
    })[tree.key];

    var stats = {
      data : data,
      data_rows : {
        true : _.pluck(target[0], "index"),
        false : _.pluck(target[1], "index")
      },
      has_children: hasChildren,
      node: tree.id
    }

    test_stats[parseInt(stats.node)] = stats;

    if(hasChildren) {
      stats.attribute = tree.key,
      stats.max_val = max;
      stats.min_val = min;
      stats.data_values = {
        true : _.pluck(target[0], tree.key),
        false : _.pluck(target[1], tree.key)
      }
      stats.split_location = {
        left_side: split[1],
        right_side: split[0]
      }
      stats.split_point = tree.value

      partitionFork(tree.children[0], split[1], depth+1);
      partitionFork(tree.children[1], split[0], depth+1);
    }

  }

  partitionFork(test_tree, test_set, 0);

  return {
    tree: test_tree,
    stats: test_stats
  }
}
